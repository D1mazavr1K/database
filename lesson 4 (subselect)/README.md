# Задание

1. Для каждого курса подсчитать количество различных действующих хобби на курсе.
2. Вывести всю информацию о студентах, занимающихся самым популярным хобби.
3. Вывести студентов с максимальным баллом в пределах их группы (если есть несколько студентов с баллом 5, вывести всех)
4. Вывести всю информацию о студентах, чей балл выше среднего по их группе.
5. Для каждой группы в одном запросе вывести количество студентов, максимальный балл в группе, средний балл в группе, минимальный балл в группе
6. Вывести номера групп, в которых не менее 75% студентов имеют балл не ниже 4
7. Для каждого хобби вывести количество людей, которые им занимаются в текущей момент
8. Вывести для каждого студента количество хобби которыми он занимается или занимался раньше, если 
не занимался хобби вывести сообщение "не занимался"

# Вложенные подзапросы

Вложенный подзапрос – это оператор SELECT, заключенный в круглые скобки и вложенный в команду языка DML, 
и использующийся в качестве источника данных для параметров SELECT, FROM, WHERE и HAVING.
Каждый подзапрос в свою очередь может содержать в себе подзапрос и т.д. 


Вложенные подзапросы всегда применяются тогда, когда для выполнения основного запроса необходимо использовать данные, 
находящиеся в той же или других таблицах, которые невозможно получить при помощи соединения таблиц. 
Например, чтобы определить, какие хобби имеют степень риска, превышающую среднюю степень риска, 
необходимо предварительно вычислить эту среднюю степень риска.


Подзапросы можно разделить на многострочные и однострочные.

1. Однострочные подзапросы возвращают в качестве результата всегда одну строку, не больше и не меньше,
поэтому над результатами выполнения таких запросов можно использовать операции сравнения.
2. Многострочные запросы в общем случае могут вернуть любое количество строк, поэтому над результатами таких подзапросов
нельзя использовать операции сравнения (если один из аргументов операции сравнения будет являться пустым множеством или
множеством, состоящим более чем из одного элемента, то запрос завершиться с ошибкой). Для таких подзапросов применимы операторы IN и EXISTS.

А еще поздапросы можно разделить на коррелированные и НЕ коррелированные (простые)

1. Простыми, или не коррелированными, подзапросами называются вложенные подзапросы, выполнение которых не зависит от внешнего запроса. 
Простые вложенные подзапросы обрабатываются системой «снизу вверх». Первым обрабатывается вложенный подзапрос самого нижнего уровня. 
Множество значений, полученное в результате его выполнения, используется при реализации подзапроса более высокого уровня и т.д. 
2. Запросы с коррелированными вложенными подзапросами обрабатываются системой в обратном порядке. 
Сначала выбирается первая строка рабочей таблицы, сформированной основным запросом, и из нее выбираются значения тех столбцов,
которые используются во вложенном подзапросе (вложенных подзапросах). Если эти значения удовлетворяют условиям вложенного 
подзапроса, то выбранная строка включается в результат. Затем выбирается вторая строка и т.д., пока в результат не будут 
включены все строки, удовлетворяющие вложенному подзапросу (последовательности вложенных подзапросов).


Следует отметить, что SQL обладает большой избыточностью в том смысле, что он часто предоставляет несколько 
различных способов формулировки одного и того же запроса. Поэтому во многих примерах данной главы при помощи 
подзапросов будут решаться задачи, часть из которых успешнее реализуется с помощью соединений, но здесь все же будут 
приведены их варианты с использованием вложенных подзапросов. Это связано с необходимостью детального знакомства с 
созданием и принципом выполнения вложенных подзапросов, так как существует немало задач 
(особенно на удаление и изменение данных), которые не могут быть реализованы другим способом

### Однострочные вложенные подзапросы

Однострочные вложенные подзапросы чаще всего применяются совместно с агрегатными функциями, результат вычисления которых и является единственным результатом подзапроса. Например:

-- получить название хобби, имеющего максимальную степень риска

```sql
SELECT name
FROM hobby
WHERE risk =
    (SELECT max(risk)
     FROM hobby)
```

### Многострочные вложенные подзапросы

Многострочные вложенные подзапросы используются для представления множества значений, исследование которых должно осуществляться в каком-либо предикате IN, что иллюстрируется в следующем примере:

-- получить номера зачеток студентов, которые не имеют ни одного хобби

```sql
SELECT id
FROM student
WHERE id NOT IN
    (SELECT DISTINCT id
     FROM student_hobby);
```

**Обратите внимание: использование вложенных запросов, когда его можно заменить на запрос с использование соединения таблиц - плохой подход.
Используйте в первую очередь соединение таблиц.**

Это просто пример, запрос выше намного разумнее написать используя `LEFT JOIN`
```sql
SELECT id
FROM student s 
    LEFT JOIN student_hobby sh on s.id = sh.id
WHERE sh.id is null
```

### Коррелированные вложенные подзапросы
Коррелированные подзапросы характерны тем, что вложенный подзапрос не может быть обработан прежде, чем будет обрабатываться внешний подзапрос. Это связано с тем, что вложенный подзапрос зависит от значения внешнего запроса, а оно изменяется по мере того, как система проверяет различные строки таблицы, указанной во внешнем запросе. Например:

-- вывести для каждого студента хобби, первое его хобби

```sql
SELECT s.surname,
       sh.h_id
FROM student s,
     student_hobby sh
WHERE sh.student_id=s.id
  AND sh.date_start=
      (
          SELECT MIN(date_start)
          FROM student_hobby
          WHERE student_id = s.id
      );
```


## Условия
В sql вы можете применять CASE для создания различных условий:

```sql
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    WHEN conditionN THEN resultN
    ELSE result
END;
```

Пример
```sql
SELECT name,
       surname,
       n_group,
       CASE
           WHEN score >= 4.75 THEN 'отличник'
           WHEN score >= 4
                AND score < 4.75 THEN 'хорошист'
           WHEN score < 4 THEN 'троешник'
           ELSE '?'
       END AS status
FROM student
```
